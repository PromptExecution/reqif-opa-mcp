## Codebase Patterns
- Project structure: reqif_mcp/ package for all implementation code
- Use ruff for linting (never black)
- Use PEP 484 type hints for all Python code
- Use uv/uvx for package management (never pip or poetry)
- Use fastmcp >= 0.4.0 for MCP server
- Use "returns" module for Rust-style Result/Option patterns
  - All functions that can fail return Result[SuccessType, Exception]
  - Use Success(value) and Failure(error) for returns
  - Match statements need explicit variable assignment for mypy exhaustiveness
- JSON schemas follow JSON Schema 2020-12 specification
- All schemas include $schema, $id, title, description, type, required, and properties fields
- Quality checks: `uv run mypy --strict` and `uv run ruff check` must pass

---

## 2026-01-30 - US-001
- Implemented canonical requirement record JSON schema for reqif-mcp/1
- Files changed:
  - Created schemas/requirement-record.schema.json
- **Learnings for future iterations:**
  - Schema directory established at `schemas/` for all data contract schemas
  - Requirement record schema defines the core data model that all other components depend on
  - Schema includes all required fields: uid, key, subtypes[], status enum, policy_baseline object, rubrics[], text, attrs (flexible)
  - Status enum strictly limited to: active, obsolete, draft
  - Policy baseline requires id, version, and hash for traceability
  - Rubrics require engine, bundle, package, rule fields for OPA evaluation
  - Attrs object is flexible with additionalProperties:true to allow domain-specific extensions
---

## 2026-01-30 - US-002
- Implemented requirement record validation function using jsonschema
- Files changed:
  - Created reqif_mcp/__init__.py (package initialization)
  - Created reqif_mcp/validation.py (validation module with 3 functions)
  - Created pyproject.toml (project dependencies with uv)
  - Created .python-version (Python 3.10.16)
  - Created uv.lock (dependency lockfile)
- **Learnings for future iterations:**
  - Project structure created: reqif_mcp/ package with __init__.py
  - Used uv for dependency management: `uv init`, `uv add`, `uv add --dev`
  - Validation uses jsonschema Draft202012Validator for JSON Schema 2020-12 compliance
  - Validation functions return Result[ValidationResult, Exception] using returns module
  - ValidationResult TypedDict structure: {valid: bool, errors: list[ValidationErrorDetail]}
  - ValidationErrorDetail TypedDict structure: {field: str, message: str, value: Any}
  - Three validation functions created:
    1. load_schema(path) -> loads schema from file
    2. validate_requirement_record(record, schema) -> validates record against schema
    3. validate_requirement_record_from_schema_file(record, path) -> convenience function
  - All functions use Rust-style error handling with returns module (Success/Failure)
  - Type checking: mypy with --strict flag passes (added types-jsonschema stub)
  - Linting: ruff check passes (removed unused import)
  - Match statements need explicit variable assignment before match for mypy exhaustiveness checking
---
## 2026-01-30 - US-003
- Implemented ReqIF 1.2 XML parser module
- Files changed:
  - Created reqif_mcp/reqif_parser.py (256 lines)
- **Learnings for future iterations:**
  - ReqIF 1.2 XML structure has three main sections: REQ-IF-HEADER, REQ-IF-CONTENT, REQ-IF-TOOL-EXTENSION
  - Key elements in ReqIF: SpecObjects (requirements), SpecTypes (type definitions), AttributeDefinitions, AttributeValues
  - Parser uses xml.etree.ElementTree for XML parsing (standard library, no extra deps)
  - Parser accepts both file path and XML string as input (handles Path objects and strings)
  - All parsing functions return Result[Data, Exception] for consistent error handling
  - Malformed XML caught via ET.ParseError and wrapped in ValueError with clear message
  - Invalid ReqIF structure (missing root, header, content) caught and reported via Result.Failure
  - TypedDict used for structured data (ReqIFData, SpecObject, SpecType, AttributeDefinition, AttributeValue)
  - Intermediate _ContentData TypedDict needed to satisfy mypy strict typing for complex return types
  - Text elements can be None, need explicit checks: `if elem.text else ""` pattern
  - Parser extracts identifiers, type references, attribute definitions and values
  - Supports ATTRIBUTE-DEFINITION-STRING (can be extended for Integer, Real, etc.)
  - Quality checks: mypy --strict and ruff check both pass
---

## 2026-01-30 - US-004
- Implemented ReqIF normalization module that transforms ReqIF data into canonical requirement records
- Files changed:
  - Created reqif_mcp/normalization.py (256 lines)
  - Modified reqif_mcp/__init__.py (added normalize_reqif export)
  - Modified pyproject.toml (added python-ulid dependency)
  - Modified uv.lock (updated dependencies)
- **Learnings for future iterations:**
  - Normalization module uses ULID library for stable, sortable unique identifiers
  - Main function: normalize_reqif(reqif_data, policy_baseline_id, policy_baseline_version) -> Result[list[dict], Exception]
  - Normalization strategy: build lookup maps for SpecTypes and AttributeDefinitions, then normalize each SpecObject
  - UID extraction: use ReqIF identifier if valid (alphanumeric + _-), otherwise generate ULID
  - Attribute mapping: ReqIF AttributeValues mapped to normalized fields via AttributeDefinition long_name
  - Attribute normalization: lowercase, replace spaces/hyphens with underscores
  - Subtypes extraction: check subtypes attribute, type attribute, or infer from SpecType long_name (default: ["GENERAL"])
  - Status validation: ensure status is one of active/obsolete/draft (default: "active")
  - Policy baseline: includes id, version, and computed hash (SHA256 of id:version for MVP)
  - Default rubrics: generate OPA rubric for each subtype (engine=opa, bundle=org/compliance, package=compliance.{subtype}, rule=decision)
  - Optional attrs object: only include if non-empty (severity, owner, verify_method)
  - Return type: Result[list[dict[str, Any]], Exception] for consistent error handling
  - Quality checks: mypy --strict and ruff check both pass
---

